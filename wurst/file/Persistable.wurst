package Persistable

import PacketIO
import Network
import DataInterfaces
import Base64Data
import Box
import ErrorHandling

/**
    A simple interface allowing to insert custom user code
    during the serialization and deserialization phases
    of Persistable, for example, to introduce encryption
    to the output.
**/
public interface PersistableMiddleware
    /**
        Called right before the data is written to a file.
        The returned BigString will be used instead.
    **/
    function encode(BigString input) returns BigString
    
    /**
        Called right before the data is deserialized from a file.
        The returned BigString will be used instead.
    **/
    function decode(BigString input) returns BigString

/**
    Represents various failures that can occur during loading.

    SUCCESS - No error has occured.
    FAIL_READ - Error while trying to read data. Could be due to a programming error, or failing checksum, which means the file is missing or has been tampered with.
    FAIL_TRANSFER - Error while trying to transfer data to/from Network.
    FAIL_DESERIALIZE - Error while trying to deserialize the class.
    FAIL_NO_PLAYER - Error due to the owner not being present in the game anymore.
**/
public enum LoadStatus
    SUCCESS
    FAIL_READ
    FAIL_TRANSFER
    FAIL_DESERIALIZE
    FAIL_NO_PLAYER

public interface PersistableLoadCallback
    function onLoaded(LoadStatus status)

public interface PersistableSaveCallback
    function onSaved()

public abstract class Persistable implements DataSerializable
    protected player owner
    private PersistableMiddleware middleware

    construct(player owner)
        this.owner = owner
    
    construct(player owner, PersistableMiddleware middleware)
        this.owner = owner
        this.middleware = middleware

    ondestroy
        if middleware != null
            destroy middleware

    abstract function getPath() returns string
    protected function onLoaded(LoadStatus _status)
    protected function onSaved()

    protected function getWriter() returns DataWriter
        return new Base64DataWriter(MAX_PACKET_LENGTH)

    protected function getReader(BigString data) returns DataReader
        return new Base64DataDecoder().decode(data)

    private function readIntoNetwork(Network network)
        Box<LoadStatus> statusBox = new Box<LoadStatus>(LoadStatus.SUCCESS)
        Box<DataReader> readerBox = new Box<DataReader>(null)

        let readSuccess = try() ->
            PacketReader.open(getPath())
            let checksum = PacketReader.read().toInt()
            var data = PacketReader.readBigString()
            if checksum != data.checksum()
                destroy data
                error("Persistable: checksum failed to validate")
            if middleware != null
                data = middleware.decode(data)
            readerBox.inner = getReader(data)

        let reader = readerBox.inner
        destroy readerBox

        if readSuccess and reader != null
            network.write() (writer) ->
                writer.writeInt(LoadStatus.SUCCESS castTo int)

            let deserializeSuccess = try() ->
                reader.readSerializable(this)

            if deserializeSuccess
                let transferSuccess = try() ->
                    network.write() (writer) ->
                        writer.writeSerializable(this)
                
                if transferSuccess
                    destroy reader
                    return
                else
                    statusBox.inner = FAIL_TRANSFER
            else
                statusBox.inner = FAIL_DESERIALIZE
        else
            statusBox.inner = FAIL_READ

        network.write() (writer) ->
            writer.clear()
            writer.writeInt(statusBox.inner castTo int)
        
        destroy statusBox
        destroy reader

    private function finishLoad(LoadStatus status, PersistableLoadCallback callback)
        onLoaded(status)
        if callback != null
            callback.onLoaded(status)
            destroy callback

    private function finishSave(PersistableSaveCallback callback)
        onSaved()
        if callback != null
            callback.onSaved()
            destroy callback

    function load(PersistableLoadCallback callback)
        let network = new Network(owner)

        if localPlayer == owner
            readIntoNetwork(network)

        network.start() (status, reader) ->
            if status == NetworkResult.ABORTED
                finishLoad(LoadStatus.FAIL_NO_PLAYER, callback)
            else
                let loadStatus = reader.readInt() castTo LoadStatus

                if loadStatus == LoadStatus.SUCCESS
                    if localPlayer != owner
                    this.deserialize(reader)
                    finishLoad(LoadStatus.SUCCESS, callback)
                else
                    finishLoad(loadStatus, callback)

    function load()
        load(null)

    function save(PersistableSaveCallback callback)
        if localPlayer == owner
            let writer = getWriter()
            writer.writeSerializable(this)
            var data = writer.intoEncoder().encode()
            if middleware != null
                data = middleware.encode(data)
            PacketWriter.initialize()
            PacketWriter.write(data.checksum().toString())
            PacketWriter.write(data)
            PacketWriter.commit(getPath())
        finishSave(callback)
    
    function save()
        save(null)