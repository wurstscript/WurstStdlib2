package SyncSimple
import LinkedList
import ChunkedString

/* 	Simple String syncing for Patches 1.31 and up with chunked string support for big data.
	For better safety sync operations are performed sequentially, one string/chunk at a time.

	Sync a string:
	>	myString.sync() (synced) ->
	>		Log.info("string synced: " + synced)

	Sync a ChunkedString:
	>	myChunkedString.sync() (synced) ->
	>		while synced.hasChunk()
	>			Log.info("chunked string synced: " + synced.readChunk())

*/

@configurable public constant DEFAULT_PREFIX = "S"
@configurable public constant LAST_CHUNK_PREFIX = "T"

public interface StringSyncListener
	function onDataSynced(string data)

public interface BufferSyncListener
	function onDataSynced(ChunkedString buffer)

class SyncData
	StringSyncListener slistener = null
	BufferSyncListener blistener = null
	player syncer = null
	string data = null
	ChunkedString buffer = null
	ChunkedString syncBuffer = null

	construct(player syncer, StringSyncListener slistener, string data)
		this.slistener = slistener
		this.data = data
		this.syncer = syncer

	construct(player syncer, BufferSyncListener blistener, ChunkedString data)
		this.blistener = blistener
		this.buffer = data
		this.syncer = syncer
		this.syncBuffer = new ChunkedString()

	ondestroy
		if slistener != null
			destroy slistener
		if blistener != null
			destroy blistener
		if buffer != null
			destroy buffer

constant syncQueue = new LinkedList<SyncData>

public function ChunkedString.sync(player p, BufferSyncListener listener)
	syncQueue.add(new SyncData(p, listener, this))

	if syncQueue.size() == 1
		checkQueue()

public function string.sync(player p, StringSyncListener listener)
	syncQueue.add(new SyncData(p, listener, this))

	if syncQueue.size() == 1
		checkQueue()

function checkQueue()
	if not syncQueue.isEmpty()
		let syncData = syncQueue.getFirst()
		if syncData.data != null
			if localPlayer == syncData.syncer
				BlzSendSyncData(DEFAULT_PREFIX, syncData.data)
		else
			let data = syncData.buffer.readChunk()
			let hasChunk = syncData.buffer.hasChunk()
			if localPlayer == syncData.syncer
				if hasChunk
					BlzSendSyncData(DEFAULT_PREFIX, data)
				else
					BlzSendSyncData(LAST_CHUNK_PREFIX, data)
init
	let trig = CreateTrigger()
	for i = 0 to bj_MAX_PLAYER_SLOTS - 1
		BlzTriggerRegisterPlayerSyncEvent(trig, players[i], DEFAULT_PREFIX, false)
		BlzTriggerRegisterPlayerSyncEvent(trig, players[i], LAST_CHUNK_PREFIX, false)

	trig.addAction() ->
		let eventData = BlzGetTriggerSyncData()
		let eventPrefix = BlzGetTriggerSyncPrefix()
		let syncData = syncQueue.getFirst()
		if syncData.data != null
			syncData.slistener.onDataSynced(eventData)
			syncQueue.dequeue()
			destroy syncData
		else
			syncData.syncBuffer.append(eventData)
			if eventPrefix == LAST_CHUNK_PREFIX
				syncData.blistener.onDataSynced(syncData.syncBuffer)
				syncQueue.dequeue()
				destroy syncData
		checkQueue()

